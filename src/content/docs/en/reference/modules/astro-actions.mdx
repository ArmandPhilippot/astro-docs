---
title: Actions API Reference
sidebar:
  label: 'astro:actions'
i18nReady: true
tableOfContents:
  minHeadingLevel: 2
  maxHeadingLevel: 6
---
import Since from '~/components/Since.astro';
import ReadMore from '~/components/ReadMore.astro';

<p>
<Since v="4.15.0" />
</p>

Actions help you build a type-safe backend you can call from client code and HTML forms. All utilities to define and call actions are exposed by the `astro:actions` module. For examples and usage instructions, [see the Actions guide](/en/guides/actions/).

## Imports from `astro:actions`

```js
import { 
  ActionError,
  ActionInputError,
  actions,
  appendForwardSlash,
  defineAction,
  deserializeActionResult,
  formDataToObject,
  getActionContext,
  getActionPath,
  getActionQueryString,
  isActionError,
  isInputError,
  serializeActionResult,
 } from 'astro:actions';
```

### `defineAction()`

<p>

**Type:** <code>\<TOutput, TAccept, TInputSchema\>(\{ accept, input, handler \}) => <a href="#actionclient">ActionClient</a>\<TOutput, TAccept, TInputSchema\> & string</code>
</p>

The `defineAction()` utility is used to define new actions from the `src/actions/index.ts` file. This accepts a [`handler()`](#handler-property) function containing the server logic to run, and an optional [`input`](#input-validator) property to validate input parameters at runtime.

```ts title="src/actions/index.ts"
import { defineAction } from 'astro:actions';
import { z } from 'astro:schema';

export const server = {
  getGreeting: defineAction({
    input: z.object({
      name: z.string(),
    }),
    handler: async (input, context) => {
      return `Hello, ${input.name}!`
    }
  })
}
```

#### `handler()` property

<p>

**Type:** <code><a href="#actionhandler">ActionHandler</a>\<TInputSchema, TOutput\></code>
</p>

`defineAction()` requires a `handler()` function containing the server logic to run when the action is called. Data returned from the handler is automatically serialized and sent to the caller.

The `handler()` is called with user input as its first argument. If an [`input`](#input-validator) validator is set, the user input will be validated before being passed to the handler. The second argument is a `context` object containing most of Astroâ€™s [standard endpoint context](/en/reference/api-reference/), excluding  `getActionResult()`, `callAction()`, and `redirect()`.

Return values are parsed using the [devalue library](https://github.com/Rich-Harris/devalue). This supports JSON values and instances of `Date()`, `Map()`, `Set()`, and `URL()`.

#### `input` validator

<p>

**Type:** `ZodType | undefined`
</p>

The optional `input` property accepts a Zod validator (e.g. Zod object, Zod discriminated union) to validate handler inputs at runtime. If the action fails to validate, [a `BAD_REQUEST` error](#actionerror) is returned and the `handler` is not called.

If `input` is omitted, the `handler` will receive an input of type `unknown` for JSON requests and type `FormData` for form requests.

#### `accept` property

<p>

**Type:** <code><a href="#actionaccept">ActionAccept</a> | undefined</code><br />
**Default:** `json`
</p>

If your action accepts form inputs, use the `z.object()` validator to automatically parse form data to a typed object. All Zod validators are supported for form data fields (e.g. `z.coerce.date()`). Astro additionally provides special handling under the hood for your convenience for validating the following types of field inputs:

- Inputs of type `number` can be validated using `z.number()`
- Inputs of type `checkbox` can be validated using `z.coerce.boolean()`
- Inputs of type `file` can be validated using `z.instanceof(File)`
- Multiple inputs of the same `name` can be validated using `z.array(/* validator */)`
- All other inputs can be validated using `z.string()`

Extension functions including `.refine()`, `.transform()`, and `.pipe()` are also supported on the `z.object()` validator.

To apply a union of different validators, use the `z.discriminatedUnion()` wrapper to narrow the type based on a specific form field. This example accepts a form submission to either "create" or "update" a user, using the form field with the name `type` to determine which object to validate against:

```ts
import { defineAction } from 'astro:actions';
import { z } from 'astro:schema';

export const server = {
  changeUser: defineAction({
    accept: 'form',
    input: z.discriminatedUnion('type', [
      z.object({
        // Matches when the `type` field has the value `create`
        type: z.literal('create'),
        name: z.string(),
        email: z.string().email(),
      }),
      z.object({
        // Matches when the `type` field has the value `update`
        type: z.literal('update'),
        id: z.number(),
        name: z.string(),
        email: z.string().email(),
      }),
    ]),
    async handler(input) {
      if (input.type === 'create') {
        // input is { type: 'create', name: string, email: string }
      } else {
        // input is { type: 'update', id: number, name: string, email: string }
      }
    },
  }),
};
```

### `isInputError()`

<p>

**Type:** `(error?: unknown) => boolean`
</p>

The `isInputError()` utility is used to check whether an `ActionError` is an input validation error. When the `input` validator is a `z.object()`, input errors include a `fields` object with error messages grouped by name.

<ReadMore>See the [form input errors guide](/en/guides/actions/#displaying-form-input-errors) for more on using `isInputError()`.</ReadMore>

### `isActionError()`

<p>

**Type:** `(error?: unknown) => boolean`
</p>

The `isActionError()` utility is used to check whether your action raised an `ActionError` within the [handler property](/en/reference/modules/astro-actions/#handler-property). This is useful when narrowing the type of a generic error in a `try / catch` block.

### `ActionError`

The `ActionError()` constructor is used to create errors thrown by an action `handler`. This accepts a `code` property describing the error that occurred (example: `"UNAUTHORIZED"`), and an optional `message` property with further details.

The following example creates a new `ActionError` when the user is not logged in:

```ts title="src/actions/index.ts" {8-11} "ActionError"
import { defineAction, ActionError } from "astro:actions";

export const server = {
  getUserOrThrow: defineAction({
    accept: 'form',
    handler: async (_, { locals }) => {
      if (locals.user?.name !== 'florian') {
        throw new ActionError({
          code: 'UNAUTHORIZED',
          message: 'Not logged in',
        });
      }
      return locals.user;
    },
  }),
}
```


You can also use `ActionError` to narrow the error type when handling the results of an action:

```astro title="src/pages/index.astro" {9-12} "ActionError"
---
---

<script>
import { ActionError, actions } from 'astro:actions';

async () => {
  const { data, error } = await actions.myAction({ /* ... */ });
  if (err instanceof ActionError) {
    // Handle action-specific errors
    console.log(err.code);
  }
}
</script>
```

#### `code`

<p>

**Type:** <code><a href="#actionerrorcode">ActionErrorCode</a></code>
</p>

Defines a human-readable version of an [HTTP status code](#actionerrorcode).

#### `message`

<p>

**Type:** `string`
</p>

An optional property to describe the error (e.g. "User must be logged in.").

#### `stack`

<p>

**Type:** `string`
</p>

An optional property to pass the stack trace.

### `getActionContext()`

<p>

**Type:** <code>(context: <a href="/en/reference/api-reference/">APIContext</a>) => <a href="#astroactioncontext">AstroActionContext</a></code><br />
<Since v="5.0.0" />
</p>

`getActionContext()` is a function called from your middleware handler to retrieve information about inbound action requests. 

This function returns an `action` object with information about the request, and the `setActionResult()` and `serializeActionResult()` functions to programmatically set the value returned by `Astro.getActionResult()`.

`getActionContext()` lets you programmatically get and set action results using middleware, allowing you to persist action results from HTML forms, gate action requests with added security checks, and more.

```ts title="src/middleware.ts" {5}
import { defineMiddleware } from 'astro:middleware';
import { getActionContext } from 'astro:actions';

export const onRequest = defineMiddleware(async (context, next) => {
  const { action, setActionResult, serializeActionResult } = getActionContext(context);
  if (action?.calledFrom === 'form') {
    const result = await action.handler();
    setActionResult(action.name, serializeActionResult(result));
  }
  return next();
});
```

### `serializeActionResult()`

<p>

**Type:** <code>(res: <a href="#saferesult">SafeResult</a>\<any, any\>) => <a href="#serializedactionresult">SerializedActionResult</a></code>
</p>

Serializes an action result to JSON for persistence. This is required to properly handle non-JSON return values like `Map` or `Date` as well as the `ActionError` object.

Call this function when serializing an action result to be passed to `setActionResult()`:

```ts title="src/middleware.ts" {8}
import { defineMiddleware } from 'astro:middleware';
import { getActionContext } from 'astro:actions';

export const onRequest = defineMiddleware(async (context, next) => {
  const { action, setActionResult, serializeActionResult } = getActionContext(context);
  if (action) {
    const result = await action.handler();
    setActionResult(action.name, serializeActionResult(result));
  }
  // ...
});
```

### `deserializeActionResult()`

<p>

**Type:** <code>(res: <a href="#serializedactionresult">SerializedActionResult</a>) => <a href="#saferesult">SafeResult</a>\<any, any\></code>
</p>

Reverses the effect of `serializeActionResult()` and returns an action result to its original state. This is useful to access the `data` and `error` objects on a serialized action result.

### `getActionPath()`

<p>

**Type:** <code>(action: <a href="#actionclient">ActionClient</a>\<any, any, any\>) => string</code>
<Since v="5.1.0" />
</p>

The `getActionPath()` utility accepts an action and returns a URL path so you can execute an action call as a `fetch()` operation directly. This allows you to provide details such as custom headers when you call your action. Then, you can [handle the custom-formatted returned data](/en/guides/actions/#handling-returned-data) as needed, just as if you had called an action directly.

This example shows how to call a defined `like` action passing the `Authorization` header and the [`keepalive`](https://developer.mozilla.org/en-US/docs/Web/API/Request/keepalive) option:

```astro title="src/components/my-component.astro" {8,11}
<script>
import { actions, getActionPath } from 'astro:actions'

await fetch(getActionPath(actions.like), {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    Authorization: 'Bearer YOUR_TOKEN'
  },
  body: JSON.stringify({ id: 'YOUR_ID' }),
  keepalive: true
})
</script>
```

This example shows how to call the same `like` action using the [`sendBeacon`](https://developer.mozilla.org/en-US/docs/Web/API/Navigator/sendBeacon) API:

```astro title="src/components/my-component.astro" {5} "sendBeacon"
<script>
import { actions, getActionPath } from 'astro:actions'

navigator.sendBeacon(
  getActionPath(actions.like),
  new Blob([JSON.stringify({ id: 'YOUR_ID' })], {
    type: 'application/json'
  })
)
</script>
```

### `actions`

<p>

**Type:** <code>Record\<string, <a href="#actionclient">ActionClient</a>\></code>
</p>

An object containing all your actions with the action name as key associated to a function to call this action.

```astro title="src/pages/index.astro" {5,8}
---
---

<script>
import { actions } from 'astro:actions';

async () => {
  const { data, error } = await actions.myAction({ /* ... */ });
}
</script>
```

In order for Astro to recognize this property, you may need to restart the dev server or [sync the module](/en/reference/cli-reference/#astro-dev) (`s + enter`).

### `appendForwardSlash()`

<p>

**Type:** `(path: string) => string`<br />
<Since v="5.0.6" />
</p>

A utility to add a trailing slash to the given string if it does not already end with a slash.

```ts title="src/actions/index.ts" "appendForwardSlash"
import { appendForwardSlash, defineAction } from "astro:actions";

export const server = {
  myAction: defineAction({
    handler: async ({ url }, context) => {
      const normalizedUrl = appendForwardSlash(url);
      /* ... */
    },
  }),
}
```

### `formDataToObject()`

<p>

**Type:** `<T extends AnyZodObject>(formData: FormData, schema: T) => Record<string, unknown>`
</p>

Transforms form data into an object based on a Zod schema. This can be useful for converting user data obtained via a form while your action handler expects an object.

```astro title="src/pages/contact.astro" {5,11} "formDataToObject"
---
---

<script>
import { actions, formDataToObject } from 'astro:actions';

const form = document.querySelector('form');
form?.addEventListener('submit', async (e) => {
  e.preventDefault();
  const formData = new FormData(form);
  const { data, error } = await actions.sendMail(formDataToObject(formData));
});
</script>
```

### `getActionQueryString()`

<p>

**Type:** `(name: string) => string`
</p>

Creates a URL query string prefixed with a question mark, containing the action parameter (`_action`) and an encoded version of the provided name. For example, calling `getActionQueryString("register")` returns `?_action=register`.

### `ActionInputError`

Creates a new error by passing an array of Zod issues to its constructor. This is useful to create a different type of error when an action input fails schema validation.

You usually don't need to construct this error yourself. However, you can use it to refine the error type and handle it differently.

The following example will log errors to the console if the error received when updating an email address is an `ActionInputError`:

```astro title="src/pages/dashboard/account.astro" {13} "ActionInputError"
---
---

<!-- your template -->

<script>
import { ActionInputError, actions } from 'astro:actions';

const input = document.querySelector('input');
input?.addEventListener('change', async () => {
  if (e.currentTarget instanceof HTMLInputElement) {
    const { data, error } = await actions.updateEmail(e.currentTarget.value);
    if (error instanceof ActionInputError) console.error(error);
    /* ... */
  }
})
</script>
```

## `astro:actions` types

```ts
import type {
  ActionAPIContext,
  ActionAccept,
  ActionClient,
  ActionErrorCode,
  ActionHandler,
  ActionReturnType,
  AstroActionContext,
  SafeResult,
  SerializedActionResult,
 } from 'astro:actions';
```

### `ActionAPIContext`

<p>

**Type:** [`APIContext`](/en/reference/api-reference/)
</p>

A subset of the Astro context object. The following properties are not available: `callAction`, `getActionResult`, `props`, and `redirect`.

### `ActionAccept`

<p>

**Type:** `"form" | "json"`
</p>

Represents the format expected by an action:
* `form`: When an action receives `FormData` from a form submission.
* `json`: When an action receives an object matching its schema. This is the format to use in most cases.

### `ActionClient`

<p>

**Types:**
* `(input?: any) => Promise<SafeResult<never, Awaited<TOutput>>>`
* `{ queryString?: string; orThrow: (input?: any) => Promise<Awaited<TOutput>>; }`
</p>

Represents a function to be used on the client for calling an action. This accepts input data and returns a `Promise` with a `SafeResult` containing either the action's output or validation errors.

#### `queryString` property

<p>

**Type:** `string`
</p>

A string representation of the action that can be used for client-side routing or URL generation.

#### `orThrow()` property

<p>

**Type:** `(input?: any) => Promise<Awaited<TOutput>>`
</p>

An alternative method that throws an error on failure instead of returning a `SafeResult`. This is useful when you want exceptions rather than error handling.

### `ActionErrorCode`

<p>

**Type:** `string`
</p>

A union type of standard HTTP status codes [defined by IANA](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) using the human-readable versions as uppercase strings separated by an underscore (e.g. `BAD_REQUEST` or `PAYLOAD_TOO_LARGE`).

### `ActionHandler`

<p>

**Type:** <code>\<TInputSchema, TOutput\>(input: TInputSchema, context: <a href="#actionapicontext">ActionAPIContext</a>) => TOutput | Promise\<TOutput\></code>
</p>

Represents the handler function provided when defining an action. The handler receives two parameters:
* **`input`:** The validated input data. When an input schema is defined, this is typed according to the schema. Otherwise, it's untyped.
* **`context`:** An `ActionAPIContext` object containing request information like headers, cookies, and other contextual data.

### `ActionReturnType`

<p>

**Type:** <code>Awaited\<ReturnType\<<a href="#actionhandler">ActionHandler</a>\>\></code>
</p>

A utility type that extracts the output type from an `ActionHandler`. This type unwraps both the `Promise` (if the handler is async) and the `ReturnType` to give you the actual output type of an action handler.

This is primarily used internally by the framework for type inference, but can be useful if you need to reference an action's output type in your own type definitions.

### `AstroActionContext`

<p>

**Type:** `{ action?: object; setActionResult: (actionName, actionResult) => void; serializeActionResult: typeof serializeActionResult; deserializeActionResult: typeof deserializeActionResult; }`<br />
<Since v="5.4.2" />
</p>

Represents context and utilities for working with actions in Astro middleware and API routes. This context is primarily useful when you need to customize action handling in middleware.

#### `action`

<p>

**Type:** <code>\{ calledFrom: "rpc" | "form"; name: string; handler: () => Promise\<<a href="#saferesult">SafeResult</a>\<any, any\>\>; \}</code>
</p>

An optional object containing information about an inbound action request. It is available from [`getActionContext()`](#getactioncontext), and provides the action `name`, `handler`, and whether the action was called from a client-side RPC function (e.g. `actions.newsletter()`) or an HTML form action.

```ts title="src/middleware.ts" {6}
import { defineMiddleware } from 'astro:middleware';
import { getActionContext } from 'astro:actions';

export const onRequest = defineMiddleware(async (context, next) => {
  const { action, setActionResult, serializeActionResult } = getActionContext(context);
  if (action?.calledFrom === 'rpc' && action.name.startsWith('private')) {
    // Check for a valid session token
  }
  // ...
});
```

##### `calledFrom`

<p>

**Type:** `"rpc" | "form"`
</p>

Whether an action was called using an RPC function or an HTML form action.

##### `name`

<p>

**Type:** `string`
</p>

The name of the action. Useful to track the source of an action result during a redirect.

##### `handler()`

<p>

**Type:** <code>() => Promise\<<a href="#saferesult">SafeResult</a>\<any, any\>\></code>
</p>

A method allowing you to programmatically call the action to get the result.

#### `setActionResult()` property

<p>

**Type:** <code>(actionName: string, actionResult: <a href="#serializedactionresult">SerializedActionResult</a>) => void</code>
</p>

A function to programmatically set the value returned by `Astro.getActionResult()` in middleware. It is passed the action name and an action result serialized by [`serializeActionResult()`](#serializeactionresult). Calling this function from middleware will disable Astro's own action result handling.

This is useful when calling actions from an HTML form to persist and load results from a session.

```ts title="src/middleware.ts" {8}
import { defineMiddleware } from 'astro:middleware';
import { getActionContext } from 'astro:actions';
export const onRequest = defineMiddleware(async (context, next) => {
  const { action, setActionResult, serializeActionResult } = getActionContext(context);
  if (action?.calledFrom === 'form') {
    const result = await action.handler();
    // ... handle the action result
    setActionResult(action.name, serializeActionResult(result));
  }
  return next();
});
```

<ReadMore>See the [advanced sessions guide](/en/guides/actions/#advanced-persist-action-results-with-a-session) for a sample implementation using Netlify Blob.</ReadMore>

#### `serializeActionResult()` property

Serializes an action result to stored in a cookie or session. Also used to pass a result to Astro templates via `setActionResult()`. This is the [same function available from `astro:actions`](#serializeactionresult).

#### `deserializeActionResult()` property

Deserializes an action result to access data and error objects. This is the [same function available from `astro:actions`](#deserializeactionresult).

### `SafeResult`

<p>

**Type:** `{ data: TOutput, error: undefined } | { data: undefined, error: ActionError }`
</p>

Represents the result of an action call:
* on success, `data` contains the output of the action and `error` is `undefined`.
* on failure, `error` contains an [`ActionError`](#actionerror) with validation errors or runtime errors, and `data` is `undefined`.

### `SerializedActionResult`

<p>

**Types:** 
* `{ type: "data"; contentType: "application/json+devalue"; status: 200; body: string; }`
* `{ type: "error"; contentType: "application/json"; status: number; body: string; }`
* `{ type: "empty"; status: 204; }`
</p>

Represents a serialized result as returned by the server before being parsed by the client:
* **`data`:** A successful result with `status` 200. The `body` contains the serialized output using the `application/json+devalue` format.
* **`error`:** A failed result with an error `status` code. The `body` contains the serialized error details in standard JSON format.
* **`empty`:** A successful result with no data, indicated by its 204 `status` (No Content).
